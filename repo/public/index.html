<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>E-Catalogue</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Your base CSS -->
  <link rel="stylesheet" href="./style.css" />

  <!-- Tailwind (can be non-deferred) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React + ReactDOM + Babel MUST be deferred -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin defer></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin defer></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js" defer></script>



  <!-- PDF tools (deferred + CORS) -->
 <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js" defer></script>

  <!-- Optional top-level theme CSS from ?theme= -->
  <script>
    (function () {
      const p = new URLSearchParams(location.search);
      const theme = (p.get('theme') || 'default').toLowerCase();
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = `./themes/${theme}.css`;
      link.onerror = () => console.warn('Optional theme CSS not found:', link.href);
      document.head.appendChild(link);
    })();
  </script>

  <!-- Ensure a CSS file is injected only once -->
  <script>
    function ensureCssOnce(href) {
      if (![...document.styleSheets].some(s => (s && s.href || '').includes(href))) {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = href;
        document.head.appendChild(link);
      }
    }
  </script>

  <style>
    .catw { width: min(96vw, 1125px); }

    /* Floating bubble */
    .fab { position: fixed; right: 24px; bottom: 24px; z-index: 1000; }
    .fab-panel {
      display: inline-flex; align-items: center; gap: 12px;
      padding: 18px 20px; border-radius: 9999px; background: #111; color: #fff;
      box-shadow: 0 10px 25px rgba(0,0,0,.22);
    }
    .fab-badge { display:inline-flex;align-items:center;justify-content:center;min-width:44px;height:44px;padding:0 6px;font-size:16px;border-radius:9999px;font-weight:700;background:#fff;color:#111; }
    .fab-btn { border:0;border-radius:9999px;cursor:pointer;background:rgba(255,255,255,.14);color:#fff;padding:14px 16px;font-size:15px;font-weight:600; }
    .fab-btn:disabled { opacity:.45; cursor:not-allowed; }
    @media (hover:hover){ .fab-btn:not(:disabled):hover{ background:rgba(255,255,255,.22); transform:translateY(-1px);} }
    @media (max-width:640px){ .fab { right:12px; bottom:12px; } .fab-panel { padding:8px 10px; } .fab-pop { width:min(94vw,520px); max-height:74vh; } }
    @media print { .fab { display:none !important; } }

    /* Selector popover */
    .fab-pop { position:absolute; right:0; bottom:92px; width:520px; background:#fff; color:#0f172a;
      border:1px solid rgba(0,0,0,.08); border-radius:12px; box-shadow:0 14px 36px rgba(2,6,23,.18); padding:10px; }
    .fab-pop h6{ margin:0 0 6px; font-size:12px; font-weight:700; letter-spacing:.02em; color:#0f172a; }
    .fab-input{ width:100%; border:1px solid #e2e8f0; border-radius:8px; padding:14px 16px; font-size:15px; }
    .fab-row{ display:flex; gap:6px; margin-top:8px; flex-wrap:wrap; }
    .fab-chip{ padding:10px 14px; font-size:14px; border-radius:9999px; border:1px solid #e2e8f0; background:#f8fafc; cursor:pointer; }
    .fab-chip:hover{ background:#eef2f7; }
    .fab-list{ max-height:520px; overflow:auto; border:1px solid #e2e8f0; border-radius:8px; }
    .fab-item{ display:flex; align-items:center; gap:8px; padding:10px 12px; font-size:14px; }
    .fab-item:hover{ background:#f8fafc; }
    .fab-item input[type="checkbox"]{ width:14px; height:14px; }
    .fab-item .name{ font-weight:600; color:#0f172a; }

    @media (max-width:640px){
      .fab { right:14px; bottom:14px; }
      .fab-panel { padding:12px 14px; gap:8px; }
      .fab-badge { min-width:28px; height:28px; font-size:13px; }
      .fab-btn { padding:9px 12px; font-size:13px; }
      .fab-pop { width:min(98vw,440px); max-height:84vh; bottom:76px; }
      .fab-input { padding:12px 14px; font-size:14px; }
      .fab-list { max-height:320px; }
      .fab-item { padding:8px 10px; font-size:13px; }
      .fab-item input[type="checkbox"]{ width:18px; height:18px; }
      .fab-chip { padding:8px 12px; font-size:13px; }
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <!-- Debug bubble host -->
  <div id="debug"></div>
  <script>
    (function(){
      const box = document.getElementById('debug');
      function show(msg){ box.style.display='block'; box.innerHTML = msg; }
      window.addEventListener('error', (e) => {
        show('<b>JS error:</b> ' + (e.error?.message || e.message));
        console.error(e.error || e);
      });
      window.addEventListener('unhandledrejection', (e) => {
        show('<b>Promise rejection:</b> ' + (e.reason?.message || e.reason));
        console.error('Unhandled rejection', e.reason);
      });
      window.__showDebug = show;
    })();
  </script>

  <!-- =========================================================
       REACT APP
       ========================================================= -->
  <script type="text/babel" data-presets="env,react" defer>
    const { useEffect, useMemo, useState, useContext } = React;

    /* =========================================================
       URL & GENERAL HELPERS
       ========================================================= */
    const ADMIN_URL = '/admin.html';
    const sanitize = (text) => String(text || '').replace(/[<>]/g, c => ({'<':'&lt;','>':'&gt;'}[c]));
    const toTime = (t) => (t == null) ? 0 : (typeof t === 'number' ? t : (Number.isFinite(Date.parse(t)) ? Date.parse(t) : 0));

    const getThemeFromURL = () => (new URLSearchParams(location.search).get('theme') || 'default').toLowerCase();
    const getSelectedIdsFromURL = () => {
      const p = new URLSearchParams(location.search);
      const one = (p.get('design') || '').trim();
      const many = (p.get('designs') || '').trim();
      const norm = s => s.toUpperCase().replace(/[^A-Z0-9_]+/g,'_');
      if (many) return many.split(',').map(x => norm(x)).filter(Boolean);
      if (one)  return [norm(one)];
      return [];
    };
    const setSelectedIdsInURL = (themeKey, ids) => {
      const p = new URLSearchParams(location.search);
      p.set('theme', themeKey);
      if (ids && ids.length) { p.set('designs', ids.join(',')); p.delete('design'); }
      else { p.delete('designs'); p.delete('design'); }
      const q = p.toString();
      history.replaceState(null, '', location.pathname + (q ? '?' + q : '') + location.hash);
    };
    const getSortFromURL = () => {
      const p = new URLSearchParams(location.search);
      return p.get('sort') || localStorage.getItem('catalogue:lastSort') || 'time_desc';
    };

    function normalizeTheme(s) {
      const t = String(s || 'default').trim().toLowerCase().replace(/[\s\-]+/g, '');
      if (t === '12x18' || t === '12x18theme' || t === '12x18_theme' || t === '12x18-themes' || t === '12x18themes') return '12x18theme';
      if (t === 'neo') return 'neo';
      if (t === 'default') return 'default';
      return t;
    }
    function matchesTheme(d, themeKey) { return normalizeTheme(d.theme) === normalizeTheme(themeKey); }

    async function loadCatalogue() {
      const u = '/data/catalogue.json?_=' + Date.now(); // cache-bust
      const res = await fetch(u, { cache: 'no-store' });
      if (!res.ok) throw new Error('HTTP ' + res.status);
      return res.json();
    }

    /* =========================================================
       SORT HELPERS
       ========================================================= */
    function buildManualRank(list, themeKey, catalogue) {
      const arr = catalogue?.orders?.[themeKey];
      if (Array.isArray(arr) && arr.length) {
        const m = new Map(); arr.forEach((id,i) => m.set(id,i));
        return (d) => m.has(d.id) ? m.get(d.id) : 1e9;
      }
      return (d) => (d.position ?? 1e9);
    }
    function sortDesigns(list, sortMode, themeKey, catalogue) {
      const a = list.slice();
      if (sortMode === 'name_asc') {
        a.sort((x,y) => (x.label||'').localeCompare(y.label||'', undefined, {sensitivity:'base'}));
      } else if (sortMode === 'time_desc') {
        a.sort((x,y) =>
          Math.max(toTime(y.updatedAt), toTime(y.createdAt)) -
          Math.max(toTime(x.updatedAt), toTime(x.createdAt))
        );
      } else if (sortMode === 'manual') {
        const rank = buildManualRank(a, themeKey, catalogue);
        a.sort((x,y) => rank(x) - rank(y));
      }
      return a;
    }

    /* =========================================================
       LOCAL OVERRIDES MERGE
       ========================================================= */
    const LS_KEY = 'catalogue:localOverrides';

    function readLocalOverridesSafe() {
      try { return JSON.parse(localStorage.getItem(LS_KEY) || '{}') || {}; }
      catch { return {}; }
    }
    function deepMerge(a, b) {
      if (b == null) return a;
      if (Array.isArray(a) && Array.isArray(b)) return b.slice();
      if (typeof a === 'object' && typeof b === 'object' && !Array.isArray(a) && !Array.isArray(b)) {
        const out = { ...a };
        for (const k of Object.keys(b)) out[k] = deepMerge(a?.[k], b[k]);
        return out;
      }
      return (b !== undefined ? b : a);
    }
    function mergeDesignWithOverride(design, ovMap) {
      const ov = ovMap?.[design.id];
      return ov ? deepMerge(design, ov) : design;
    }
    function mergeCatalogueWithOverrides(catalogue) {
      const ov = readLocalOverridesSafe();
      const designs = Array.isArray(catalogue?.designs) ? catalogue.designs : [];
      return { ...catalogue, designs: designs.map(d => mergeDesignWithOverride(d, ov)) };
    }

    /* =========================================================
       EDIT CONTEXT + UTILITIES
       ========================================================= */
    const EditCtx = React.createContext({ edit:false, queue:{}, setEdit:()=>{}, setField:()=>{} });

    function useEditQueue() {
      const [queue, setQueue] = useState({});
      const setField = (designId, path, value) => {
        setQueue(prev => {
          const next = {...prev};
          const node = next[designId] ?? (next[designId] = {});
          const setDeep = (obj, arr, val) => {
            const k = arr[0];
            if (arr.length === 1) { obj[k] = val; return; }
            obj[k] = obj[k] ?? {};
            setDeep(obj[k], arr.slice(1), val);
          };
          setDeep(node, path.split('.'), value);
          return next;
        });
      };
      const clearAll = () => setQueue({});
      return { queue, setField, clearAll };
    }

    async function persistDesignChanges(designId, updates) {
      const writeLocal = () => {
        const all = readLocalOverridesSafe();
        all[designId] = { ...(all[designId]||{}), ...updates };
        localStorage.setItem(LS_KEY, JSON.stringify(all));
      };
      try {
        const res = await fetch(`/api/designs/${encodeURIComponent(designId)}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ updates })
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        writeLocal();
        return true;
      } catch (e) {
        console.warn('PATCH failed, using localStorage fallback', e);
        writeLocal();
        return true;
      }
    }

    const clampDeg = (d) => Math.round(((d % 360) + 360) % 360);
    function getDeep(obj, path, fallback) {
      if (!obj) return fallback;
      const parts = path.split('.');
      let cur = obj;
      for (const p of parts) {
        if (cur && Object.prototype.hasOwnProperty.call(cur, p)) cur = cur[p];
        else return fallback;
      }
      return cur;
    }

    // Detect mobile screen (max-width: 640px)
    function useIsMobile() {
      const [isMobile, setIsMobile] = React.useState(
        window.matchMedia('(max-width: 640px)').matches
      );
      React.useEffect(() => {
        const mq = window.matchMedia('(max-width: 640px)');
        const onChange = e => setIsMobile(e.matches);
        mq.addEventListener ? mq.addEventListener('change', onChange) : mq.addListener(onChange);
        return () => {
          mq.removeEventListener ? mq.removeEventListener('change', onChange) : mq.removeListener(onChange);
        };
      }, []);
      return isMobile;
    }

    /* =========================================================
       EDITABLE PRIMITIVES
       ========================================================= */
    function EditableText({ designId, path, value, className, paragraph = false }) {
      const { edit, setField } = useContext(EditCtx);
      const [local, setLocal] = useState(value || '');
      const ref = React.useRef(null);

      useEffect(() => setLocal(value || ''), [value]);

      const placeCaretAtStart = (el) => {
        if (!el) return;
        el.scrollTop = 0;
        if (!edit) return;
        const sel = window.getSelection && window.getSelection();
        if (!sel) return;
        const range = document.createRange();
        range.selectNodeContents(el);
        range.collapse(true);
        sel.removeAllRanges();
        sel.addRange(range);
      };

      useEffect(() => {
        if (ref.current) {
          const id = requestAnimationFrame(() => placeCaretAtStart(ref.current));
          return () => cancelAnimationFrame(id);
        }
      }, [edit]);

      const push = (val) => {
        setLocal(val);
        setField(designId, path, val);
      };

      const Tag = paragraph ? 'div' : 'span';

      return (
        <Tag
          ref={ref}
          className={`${className || ''} ${paragraph ? 'editable-paragraph' : ''}`}
          contentEditable={edit}
          suppressContentEditableWarning
          onInput={(e) => push(e.currentTarget.textContent)}
          onBlur={(e) => push(e.currentTarget.textContent)}
          onFocus={(e) => placeCaretAtStart(e.currentTarget)}
          style={{
            whiteSpace: 'pre-wrap',
            display: paragraph ? 'block' : undefined,
            ...(edit
              ? {
                  outline: '1px dashed #60a5fa',
                  borderRadius: 4,
                  padding: paragraph ? '6px 8px' : '0 2px',
                  maxHeight: paragraph ? '40vh' : undefined,
                  overflow: paragraph ? 'auto' : undefined,
                }
              : {}),
          }}
          title={edit ? `Editing: ${path}` : undefined}
        >
          {local}
        </Tag>
      );
    }

    function EditableImage({ designId, path, src, alt, className, initialDeg = 0 }) {
      const { edit, setField } = useContext(EditCtx);
      const [deg, setDeg] = useState(initialDeg);
      const [open, setOpen] = useState(false);
      const isMobile = useIsMobile();
      if (!src) return null;

      const snap45 = (v) => Math.round(v / 45) * 45;

      const commitAngle = (v) => {
        const a = clampDeg(snap45(v));
        setDeg(a);
        setField(designId, `rotations.${path}`, a);
      };

      const minus45 = () => commitAngle(deg - 45);
      const plus45  = () => commitAngle(deg + 45);
      const sliderVal = (deg > 180) ? deg - 360 : deg;

      return (
        <div className="editable-image relative inline-block">
          <img
            className={className}
            src={src}
            alt={alt || ''}
            loading="lazy"
            decoding="async"
            style={{ transform: `rotate(${deg}deg)`, transition: 'transform .2s' }}
          />

          {edit && (
            <div className="absolute bottom-1 right-1">
              <button
                type="button"
                className="rounded-full bg-white/90 border border-slate-200 text-slate-700 shadow-sm hover:bg-white
                           h-7 w-7 text-[10px] sm:h-8 sm:w-8 sm:text-xs"
                onClick={() => setOpen(o => !o)}
                title="Rotate"
                aria-label="Rotate"
              >
                ⟳
              </button>

              {open && (
                <div
                  className={`absolute bottom-9 right-0 bg-white border border-slate-200 rounded-lg shadow
                              flex items-center gap-1 ${isMobile ? 'p-1 text-[10px]' : 'p-1.5 text-[11px]'}`}
                >
                  <button type="button"
                          className="px-1.5 py-1 rounded border hover:bg-slate-50"
                          onClick={minus45}
                          title="-45°">−45°</button>

                  <input
                    type="range"
                    min="-180" max="180" step="45"
                    value={sliderVal}
                    onChange={(e) => commitAngle(parseInt(e.target.value, 10))}
                    style={{ width: isMobile ? 80 : 120 }}
                    title="Angle"
                  />

                  <button type="button"
                          className="px-1.5 py-1 rounded border hover:bg-slate-50"
                          onClick={plus45}
                          title="+45°">+45°</button>
                </div>
              )}
            </div>
          )}
        </div>
      );
    }

    /* =========================================================
       THEME REGISTRY
       ========================================================= */
    const THEME_COMPONENTS = Object.create(null);
    function registerTheme(name, component) {
      THEME_COMPONENTS[normalizeTheme(name)] = component;
    }

    /* ------------------ Built-in: DefaultTheme (editable) ------------------ */
    function DefaultTheme({ d, brandLogo, sizeIcon }) {
      const rot = d.rotations || {};
      const smalls = (d.variants || []).slice(0, 3);

      const previews = [];
      if (d.preview) previews.push({ src: d.preview, path: 'preview' });
      if (Array.isArray(d.previews)) {
        d.previews.forEach((src, i) => previews.push({ src, path: `previews.${i}` }));
      }

      const main = (
        <div className="page theme-default" data-design-id={d.id}>
          <div className="video-box">
            {d.video ? (
              <>
                <video
                  controls preload="metadata" playsInline
                  onPlay={e => e.currentTarget.nextSibling.style.display = 'none'}
                  onPause={e => e.currentTarget.nextSibling.style.display = 'flex'}
                  onEnded={e => e.currentTarget.nextSibling.style.display = 'flex'}
                >
                  <source src={d.video} type="video/mp4" />
                </video>
                <div
                  className="play-overlay"
                  onClick={e => { const v = e.currentTarget.previousSibling; v.play(); e.currentTarget.style.display = 'none'; }}
                >
                  <svg viewBox="0 0 64 64"><polygon points="16,12 52,32 16,52" /></svg>
                </div>
              </>
            ) : <div className="no-video">No video</div>}
          </div>

          <div className="image-label">
            <EditableText designId={d.id} path="label" value={d.label} />
          </div>

          <div className="label-line"></div>

          <div className="image-box">
            {d.main && (
              <EditableImage
                designId={d.id}
                path="main"
                src={d.main}
                alt={(d.label || '') + ' main'}
                className="img-fit"
                initialDeg={getDeep(rot, 'main', 0)}
              />
            )}
          </div>

          <div className="small-images">
            {smalls.map((src, i) => (
              <EditableImage
                key={i}
                designId={d.id}
                path={`variants.${i}`}
                src={src}
                alt={(d.label || '') + ' v' + (i + 1)}
                initialDeg={getDeep(rot, `variants.${i}`, 0)}
              />
            ))}
          </div>

          {brandLogo && <img src={brandLogo} className="logo" alt="Logo" loading="lazy" decoding="async" />}

          <div className="info-box">
            <div className="info-line">
              Finish:&nbsp;<strong>
                <EditableText designId={d.id} path="finish" value={d.finish} />
              </strong>
            </div>

            <div className="info-line">
              Random:&nbsp;<strong>
                <EditableText
                  designId={d.id}
                  path="facesText"
                  value={d.facesText || `${d.faces || 0} face`}
                />
              </strong>
            </div>

            {d.sizeText && (
              <div className="info-line">
                Size:&nbsp;<strong>
                  <EditableText designId={d.id} path="sizeText" value={d.sizeText} />
                </strong>
              </div>
            )}
          </div>

          {sizeIcon && <img src={sizeIcon} className="bottom-right-image" alt="Size" loading="lazy" decoding="async" />}
        </div>
      );

      const prevPages = previews.map(({ src, path }, i) => (
        <div className="page theme-default" key={'p' + i} data-design-id={d.id}>
          <div className="main-image">
            <EditableImage
              designId={d.id}
              path={path}
              src={src}
              alt={(d.label || '') + ' preview ' + (i + 1)}
              className="img-fit"
              initialDeg={getDeep(rot, path, 0)}
            />
          </div>
        </div>
      ));

      return [main, ...prevPages];
    }
    registerTheme('default', DefaultTheme);

    /* ---------- Built-in: NeoTheme ---------- */
    function NeoTheme({ d, brandLogo }) {
      const t = d.themeData || {};
      const rot = d.rotations || {};
      const swatches = (t.swatches || []).slice(0,6);

      const badge = t.size_badge
        ? <EditableImage designId={d.id} path="themeData.size_badge" src={t.size_badge} alt="Size" className="bottom-right-image" initialDeg={rot?.themeData?.size_badge || 0} />
        : (t.size_text
            ? <div className="bottom-right-image" style={{width:'auto',padding:'.25rem .5rem',background:'#fff',border:'1px solid #ddd',borderRadius:'8px',fontWeight:600}}>
                <EditableText designId={d.id} path="themeData.size_text" value={t.size_text} />
              </div>
            : null);

      const main = (
        <div className="page theme-neo" data-design-id={d.id}>
          <div className="image-label"><EditableText designId={d.id} path="label" value={d.label} /></div>
          <div className="label-line"></div>

          <div className="image-box" style={{display:'grid',gridTemplateColumns:'1fr 1fr',gap:'12px'}}>
            {t.main_left && (
              <EditableImage designId={d.id} path="themeData.main_left" src={t.main_left} alt={(d.label||'')+' left'} initialDeg={rot?.themeData?.main_left || 0} />
            )}
            {t.main_right && (
              <EditableImage designId={d.id} path="themeData.main_right" src={t.main_right} alt={(d.label||'')+' right'} initialDeg={rot?.themeData?.main_right || 0} />
            )}
          </div>

          <div className="small-images">
            {swatches.map((src,i)=> (
              <EditableImage key={i} designId={d.id} path={`themeData.swatches.${i}`} src={src} alt={(d.label||'')+' swatch '+(i+1)} initialDeg={rot?.themeData?.swatches?.[i] || 0} />
            ))}
          </div>

          {brandLogo && <img src={brandLogo} className="logo" alt="Logo" loading="lazy" decoding="async" />}
          {badge}
        </div>
      );

      const previews = Array.isArray(t.previews) ? t.previews : (t.preview ? [t.preview] : []);
      const prevPages = previews.map((src,i)=>(
        <div className="page theme-neo" key={'np'+i} data-design-id={d.id}>
          <img src={src} alt={(d.label||'')+' preview '+(i+1)} className="main-image" loading="lazy" decoding="async"/>
        </div>
      ));
      return [main, ...prevPages];
    }
    registerTheme('neo', NeoTheme);

    /* ---------- Built-in: 12x18 Theme (with fixed rotations) ---------- */
    function Theme12x18({ d, brandLogo }) {
      ensureCssOnce('./themes/12x18theme.css');

      const t = d.themeData || {};
      const rot = d.rotations || {};

      const getField = (base) =>
        t[base] ?? t[base + ']['] ?? t[`files[${base}]`] ?? t[`files[${base}][]`] ?? null;
      const toArr = (v) => Array.isArray(v) ? v : (v ? [v] : []);
      const pairFrom = (aKey, bKey) => {
        const aArr = toArr(getField(aKey)); const bArr = toArr(getField(bKey));
        const a = aArr[0] ?? bArr[0] ?? null;
        const b = bArr[0] ?? aArr[1] ?? a ?? null;
        return [a, b];
      };
      const [t1a, t1b] = pairFrom('tile1a', 'tile1b');
      const [t2a, t2b] = pairFrom('tile2a', 'tile2b');
      const [t3a, t3b] = pairFrom('tile3a', 'tile3b');

      const Img = ({ id, src, alt, path }) =>
        src ? (
          <div id={id} className="abs ph">
            <EditableImage
              designId={d.id}
              path={path}
              src={src}
              alt={alt || ''}
              className="img-fit"
              initialDeg={getDeep(rot, path, 0)}
            />
          </div>
        ) : null;

      const page = (
        <div className="page theme-12x18" data-design-id={d.id}>
          {brandLogo && (
            <div id="logo" className="abs">
              <img className="img-fit" src={brandLogo} alt="Logo" loading="lazy" decoding="async" />
            </div>
          )}

          <Img id="tile1a" src={t1a} alt="Tile 1 A" path="themeData.tile1a" />
          <Img id="tile1b" src={t1b} alt="Tile 1 B" path="themeData.tile1b" />
          <Img id="tile2a" src={t2a} alt="Tile 2 A" path="themeData.tile2a" />
          <Img id="tile2b" src={t2b} alt="Tile 2 B" path="themeData.tile2b" />
          <Img id="tile3a" src={t3a} alt="Tile 3 A" path="themeData.tile3a" />
          <Img id="tile3b" src={t3b} alt="Tile 3 B" path="themeData.tile3b" />

          <div id="tile1name" className="abs font-medium"><EditableText designId={d.id} path="themeData.tile1name" value={t.tile1name || ''} /></div>
          <div id="tile2name" className="abs font-medium"><EditableText designId={d.id} path="themeData.tile2name" value={t.tile2name || ''} /></div>
          <div id="tile3name" className="abs font-medium"><EditableText designId={d.id} path="themeData.tile3name" value={t.tile3name || ''} /></div>

          {getField('preview') && (
            <div id="preview" className="abs ph">
              <EditableImage
                designId={d.id}
                path="themeData.preview"
                src={toArr(getField('preview'))[0]}
                alt="Preview"
                className="img-fit"
                initialDeg={getDeep(rot, 'themeData.preview', 0)}
              />
            </div>
          )}

          <div id="finish" className="abs spec font-light">
            <span className="bar"></span> Finish:
            &nbsp;<span className="font-bold"><EditableText designId={d.id} path="themeData.finish" value={t.finish || ''} /></span>
          </div>
          <div id="random" className="abs spec font-light">
            <span className="bar"></span> Random:
            &nbsp;<span className="font-bold"><EditableText designId={d.id} path="themeData.random" value={t.random || ''} /></span>
          </div>
          <div id="sizebox" className="abs font-bold">
            <EditableText designId={d.id} path="themeData.size_text" value={t.size_text || ''} />
          </div>
        </div>
      );

      return [page];
    }
    registerTheme('12x18theme', Theme12x18);

    /* =========================================================
       FLOATING ACTIONS
       ========================================================= */
    function FloatingActions({
      designs, selectedIds, syncSelection,
      onOpen, onPrint, onClear, onSelectAllVisible, onInvertVisible, onDownloadEcard,
      edit, setEdit, onSaveAll, pendingCount
    }) {
      const [open, setOpen] = useState(false);
      const [query, setQuery] = useState("");
      const norm = (s) => (s || "").toLowerCase();

      const all = useMemo(() => {
        const list = Array.isArray(designs) ? designs : [];
        return list.map(d => ({ id: d.id, label: d.label || d.id, finish: (d.finish || "").trim() }));
      }, [designs]);

      const filtered = useMemo(() => {
        const q = norm(query);
        let arr = all;
        if (q) arr = arr.filter(x => norm(x.label).includes(q) || norm(x.id).includes(q));
        return arr.sort((a,b) => a.label.localeCompare(b.label)).slice(0, 800);
      }, [all, query]);

      const toggle = (id) => {
        const set = new Set(selectedIds);
        if (set.has(id)) set.delete(id); else set.add(id);
        syncSelection(Array.from(set));
      };

      const selectAllFiltered = () => {
        const set = new Set(selectedIds);
        filtered.forEach(x => set.add(x.id));
        syncSelection(Array.from(set));
      };
      const clearFiltered = () => {
        const set = new Set(selectedIds);
        filtered.forEach(x => set.delete(x.id));
        syncSelection(Array.from(set));
      };

      return (
        <div className="fab print:hidden">
          <div className="fab-panel" role="group" aria-label="Selection actions">
            <button className="fab-btn" onClick={()=>setEdit(e=>!e)} title="Toggle Edit Mode">
              {edit ? 'Editing…' : 'Edit'}
            </button>
            {pendingCount > 0 && (
              <button className="fab-btn" onClick={onSaveAll} title="Save all edits">
                Save
              </button>
            )}

            <button className="fab-btn" onClick={()=>setOpen(o=>!o)} title="Select from list / Search">
              Select
            </button>
            <span className="fab-badge" title="Selected count">{selectedIds.length}</span>

            {selectedIds.length > 0 && (
              <>
                <button className="fab-btn" onClick={onOpen} title="Open selected">Open</button>
                <button className="fab-btn" onClick={onPrint} title="Print / Save PDF">Print</button>
                <button className="fab-btn" onClick={onClear} title="Clear selection">Clear</button>
                <button className="fab-btn" onClick={onDownloadEcard} title="Download selected pages as an e-card PDF">
                  Download e-card
                </button>
              </>
            )}
          </div>

          {open && (
            <div className="fab-pop">
              <h6 style={{marginTop:10}}>Search designs</h6>
              <input className="fab-input" placeholder="Type design name or ID…" value={query} onChange={e=>setQuery(e.target.value)} />
              <div className="fab-subtle" style={{marginTop:6, marginBottom:6}}>Showing {filtered.length} of {all.length}</div>

              <div className="fab-list">
                {filtered.map(x => {
                  const checked = selectedIds.includes(x.id);
                  return (
                    <label key={x.id} className="fab-item">
                      <input type="checkbox" checked={checked} onChange={()=>toggle(x.id)} />
                      <span className="name">{x.label}</span>
                    </label>
                  );
                })}
              </div>

              <div className="fab-row" style={{marginTop:8}}>
                <span className="fab-chip" onClick={selectAllFiltered}>Select All (filtered)</span>
                <span className="fab-chip" onClick={clearFiltered}>Clear (filtered)</span>
                <span className="fab-chip" onClick={onSelectAllVisible}>Add Visible</span>
                <span className="fab-chip" onClick={onInvertVisible}>Invert Visible</span>
              </div>
            </div>
          )}
        </div>
      );
    }

    /* =========================================================
       APP
       ========================================================= */
    function App(){
      const [catalogue, setCatalogue] = useState(null);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState('');

      const [edit, setEdit] = useState(false);
      const { queue, setField, clearAll } = useEditQueue();

      const themeKey = getThemeFromURL();
      const sortMode = getSortFromURL();
      const params = new URLSearchParams(location.search);
      const mode = params.get('mode') || '';

      const [selectedIds, setSelectedIds] = useState(getSelectedIdsFromURL());
      const syncSelection = (ids) => { setSelectedIds(ids); setSelectedIdsInURL(themeKey, ids); };

      // ----- share URL used inside the PDF header
      
const buildShareURL = () => {
  const p = new URLSearchParams(location.search);
  p.set('theme', themeKey);

  if (selectedIds.length === 1) {
    p.set('mode', 'selected');
    p.set('design', selectedIds[0]);
    p.delete('designs');
  } else if (selectedIds.length > 1) {
    p.set('mode', 'selected');
    p.set('designs', selectedIds.join(','));
    p.delete('design');
  } else {
    p.delete('mode');
    p.delete('design');
    p.delete('designs');
  }

  const qs = p.toString();
  return `${location.origin}${location.pathname}${qs ? `?${qs}` : ''}`;
};


      // ----- Download selected pages as an e-card PDF (clickable link inside)
    
// Pure jsPDF version: draws a rounded "button" and attaches a real link.

// Pretty, single-page e-card PDF with brand area + CTA button (clickable)
// Drop in to replace your current downloadEcardPdf
const downloadEcardPdf = async () => {
  if (!selectedIds.length) {
    alert('Select at least one design to export.');
    return;
  }

  // -------- Build destination URL (single vs multi) ----------
  const p = new URLSearchParams(location.search);
  p.set('theme', themeKey);
  if (selectedIds.length === 1) {
    p.set('mode', 'selected');
    p.set('design', selectedIds[0]);
    p.delete('designs');
  } else {
    p.set('mode', 'selected');
    p.set('designs', selectedIds.join(','));
    p.delete('design');
  }
  const destURL = `${location.origin}${location.pathname}?${p.toString()}`;
  const ctaLabel = selectedIds.length === 1 ? 'Open selected design' : 'Open selected catalogue';

  // -------- Ensure jsPDF ready ----------
  if (!window.jspdf || !window.jspdf.jsPDF) {
    alert('PDF library not ready yet. Please try again.');
    return;
  }
  const { jsPDF } = window.jspdf;

  // -------- PDF setup ----------
  const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
  const pageW = pdf.internal.pageSize.getWidth();    // ~595
  const pageH = pdf.internal.pageSize.getHeight();   // ~842
  const margin = 36;

  // Theme colors (adjust here to rebrand)
  const bgPage = [241, 245, 249];   // #F1F5F9 slate-100
  const cardFill = [24, 31, 46];    // #181F2E dark
  const accent = [14, 165, 233];    // #0EA5E9 cyan
  const textLight = [248, 250, 252]; // #F8FAFC
  const subText = [148, 163, 184];   // #94A3B8 slate-400

  // -------- Background ----------
  pdf.setFillColor(...bgPage);
  pdf.rect(0, 0, pageW, pageH, 'F');

  // -------- Card metrics ----------
  const cardW = Math.min(520, pageW - margin * 2);
  const cardH = 260;
  const cardX = (pageW - cardW) / 2;
  const cardY = (pageH - cardH) / 2;
  const radius = 18;

  // A soft shadow (fake by drawing a light rounded rect underneath)
  pdf.setFillColor(0, 0, 0);
  pdf.setDrawColor(0, 0, 0);
  pdf.setGState && pdf.setGState(pdf.GState({ opacity: 0.10 })); // if available
  pdf.roundedRect(cardX + 4, cardY + 6, cardW, cardH, radius, radius, 'F');
  if (pdf.setGState) pdf.setGState(pdf.GState({ opacity: 1 }));

  // Card
  pdf.setFillColor(...cardFill);
  pdf.roundedRect(cardX, cardY, cardW, cardH, radius, radius, 'F');

  // -------- Brand area (logo mark + title + slogan) ----------
  const centerX = cardX + cardW / 2;

  // Logo mark (circle). If you prefer an image, see “Optional: real logo” below.
  const markR = 12;
  const markY = cardY + 34;
  pdf.setFillColor(...accent);
  pdf.circle(centerX, markY, markR, 'F');

  // Title (brand)
  const brandText = (catalogue?.brandName || 'LOGO HERE').toUpperCase();
  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(18);
  pdf.setTextColor(...textLight);
  pdf.text(brandText, centerX, markY + 28, { align: 'center' });

  // Slogan
  const slogan = (catalogue?.slogan || 'SLOGAN').toUpperCase();
  pdf.setFont('helvetica', 'normal');
  pdf.setFontSize(10);
  pdf.setTextColor(...subText);
  pdf.text(slogan, centerX, markY + 46, { align: 'center' });

  // Decorative side notches (optional)
  const notchW = 28, notchH = 10, notchR = 6, notchY = cardY + cardH / 2 - notchH / 2;
  pdf.setFillColor(...accent);
  pdf.roundedRect(cardX + 12, notchY, notchW, notchH, notchR, notchR, 'F');
  pdf.roundedRect(cardX + cardW - notchW - 12, notchY, notchW, notchH, notchR, notchR, 'F');

  // -------- CTA button ----------
  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(12);
  const labelW = pdf.getTextWidth(ctaLabel);
  const padX = 18, padY = 10;
  const btnW = Math.max(180, labelW + padX * 2);
  const btnH = 36;
  const btnX = centerX - btnW / 2;
  const btnY = cardY + cardH - 64;

  pdf.setFillColor(...accent);
  pdf.roundedRect(btnX, btnY, btnW, btnH, 10, 10, 'F');

  pdf.setTextColor(255, 255, 255);
  pdf.text(ctaLabel, centerX, btnY + btnH / 2 + 4, { align: 'center', baseline: 'middle' });

  // Make it clickable
  pdf.link(btnX, btnY, btnW, btnH, { url: destURL });

  // -------- Footer link text (website) ----------
  const site = (catalogue?.website || location.host || 'yourwebsite.com');
  pdf.setFont('helvetica', 'normal');
  pdf.setFontSize(9);
  pdf.setTextColor(...subText);
  pdf.text(site, centerX, cardY + cardH - 18, { align: 'center' });

  // (Optional) underline footer to hint it's a link (and make it clickable too)
  const siteW = pdf.getTextWidth(site);
  const siteX = centerX - siteW / 2;
  pdf.link(siteX - 2, cardY + cardH - 30, siteW + 4, 18, { url: `https://${site}` });

  // -------- Save ----------
  pdf.save('e-card-selected.pdf');

  /* -----------------------------
   * Optional: real logo support
   * If you have `catalogue.brandLogo` (same-origin or CORS-enabled),
   * replace the circle “logo mark” with the image:
   *
   *  try {
   *    const imgData = await fetch(catalogue.brandLogo, { mode: 'cors' })
   *      .then(r => r.blob())
   *      .then(b => new Promise(res => { const fr = new FileReader();
   *        fr.onload = () => res(fr.result); fr.readAsDataURL(b); }));
   *    const imgW = 48, imgH = 48;
   *    const imgX = centerX - imgW/2, imgY = cardY + 18;
   *    pdf.addImage(imgData, 'PNG', imgX, imgY, imgW, imgH);
   *  } catch(e) { /* fall back to circle */ /* }
   * ----------------------------- */
};

      // Load catalogue on mount
      useEffect(() => {
        (async () => {
          try {
            const raw = await loadCatalogue();
            const merged = mergeCatalogueWithOverrides(raw);
            setCatalogue(merged);
          } catch (err) { setError(String(err)); }
          finally { setLoading(false); }
        })();
      }, []);

      // Listen for localStorage override changes
      useEffect(() => {
        const onStorage = (e) => {
          if (e.key === LS_KEY) {
            setCatalogue(prev => prev ? mergeCatalogueWithOverrides(prev) : prev);
          }
        };
        window.addEventListener('storage', onStorage);
        return () => window.removeEventListener('storage', onStorage);
      }, []);

      // Compute visible collections
      const allForTheme = useMemo(() => {
        if (!catalogue) return [];
        const all = Array.isArray(catalogue.designs) ? catalogue.designs : [];
        const filtered = all.filter(d => matchesTheme(d, themeKey));
        return sortDesigns(filtered, sortMode, themeKey, catalogue);
      }, [catalogue, themeKey, sortMode]);

      const designs = useMemo(() => {
        if (!catalogue) return [];
        const all = Array.isArray(catalogue.designs) ? catalogue.designs : [];
        let list = all.filter(d => matchesTheme(d, themeKey));
        if (selectedIds.length) {
          const set = new Set(selectedIds);
          list = list.filter(d => set.has(d.id));
        }
        list = sortDesigns(list, sortMode, themeKey, catalogue);
        if (window.__showDebug) {
          window.__showDebug(`<b>theme:</b> ${themeKey} | <b>matches:</b> ${list.length} | <b>sort:</b> ${sortMode}`);
        }
        return list;
      }, [catalogue, themeKey, selectedIds, sortMode]);

      // Render pages from designs
      const pages = useMemo(() => {
        if (!designs.length) return [];
        const out = [];
        designs.forEach(d => {
          const C = THEME_COMPONENTS[normalizeTheme(d.theme || 'default')] || THEME_COMPONENTS.default;
          const rendered = C({ d, brandLogo: catalogue?.brandLogo, sizeIcon: catalogue?.sizeIcon });
          if (Array.isArray(rendered)) out.push(...rendered);
          else if (rendered) out.push(rendered);
        });
        return out;
      }, [designs, catalogue]);

      // Pause videos when page leaves viewport
      useEffect(() => {
        function pauseOffscreen() {
          const ps = document.querySelectorAll('.page');
          const vh = window.innerHeight;
          ps.forEach(p => {
            const r = p.getBoundingClientRect();
            const inView = r.top >= -vh/2 && r.top < vh/2;
            p.querySelectorAll('video').forEach(v => { if (!inView) v.pause(); });
          });
        }
        pauseOffscreen();
        window.addEventListener('scroll', pauseOffscreen);
        return () => window.removeEventListener('scroll', pauseOffscreen);
      }, [pages.length]);

      const onSaveAll = async () => {
        if (document.activeElement && typeof document.activeElement.blur === 'function') {
          document.activeElement.blur();
        }
        const ids = Object.keys(queue);
        if (!ids.length) { alert('No changes to save.'); setEdit(false); return; }

        try {
          for (const id of ids) {
            const updates = queue[id];
            await persistDesignChanges(id, updates);
          }

          setCatalogue(prev => {
            if (!prev) return prev;
            const nextDesigns = (prev.designs || []).map(d => {
              const u = queue[d.id];
              return u ? deepMerge(d, u) : d;
            });
            return { ...prev, designs: nextDesigns };
          });

          const raw = await loadCatalogue();
          const patched = mergeCatalogueWithOverrides(raw);
          setCatalogue(patched);

          clearAll();
          setEdit(false);
          alert('Saved permanently!');
        } catch (e) {
          alert('Some saves failed: ' + e.message);
        }
      };

      const clearSelectionAndRefresh = () => {
        const p = new URLSearchParams(location.search);
        ['design','designs','mode'].forEach(k => p.delete(k));
        setSelectedIds([]);
        const qs = p.toString();
        location.replace(qs ? `${location.pathname}?${qs}` : location.pathname);
      };
      const openSelectedFromApp = () => {
        if (!selectedIds.length) return;
        const p = new URLSearchParams(location.search);
        p.set('theme', themeKey);
        p.set('designs', selectedIds.join(','));
        p.set('mode', 'selected');
        window.open(location.pathname + '?' + p.toString(), '_blank', 'noopener');
      };
      const printSelectedFromApp = () => { if (selectedIds.length) window.print(); };
      const getVisibleIds = () => Array.from(document.querySelectorAll('[data-design-id]')).map(el => el.getAttribute('data-design-id')).filter(Boolean);
      const selectAllVisible = () => { const vis = getVisibleIds(); if (!vis.length) return; const set = new Set(selectedIds); vis.forEach(id => set.add(id)); syncSelection(Array.from(set)); };
      const invertVisible = () => {
        const vis = getVisibleIds(); if (!vis.length) return;
        const visSet = new Set(vis); const curSet = new Set(selectedIds); const out = new Set(curSet);
        visSet.forEach(id => { if (out.has(id)) out.delete(id); else out.add(id); });
        syncSelection(Array.from(out));
      };

      const removeDesignById = async (id) => {
        const target = (designs || []).find(d => d.id === id);
        const name = target?.label || id;
        if (!confirm(`Remove “${name}”? This will delete it from the Admin as well.`)) return;

        try {
          const res = await fetch(`/api/designs/${encodeURIComponent(id)}`, { method: 'DELETE' });
          let out = null; try { out = await res.json(); } catch {}
          if (!res.ok) throw new Error(out?.error || `Delete failed (${res.status})`);

          setCatalogue(prev => prev ? ({ ...prev, designs: (prev.designs || []).filter(d => d.id !== id) }) : prev);
          setSelectedIds(prev => prev.filter(x => x !== id));
        } catch (e) {
          alert('Delete failed: ' + e.message);
        }
      };

      const openAdminForTheme = (theme) => window.open(`${ADMIN_URL}?theme=${encodeURIComponent(theme)}`, '_blank', 'noopener');

      if (loading) return <div className="mx-auto" style={{maxWidth:900,margin:'40px auto',padding:16,border:'1px solid #e5e7eb',borderRadius:12,background:'#fff'}}>Loading…</div>;
      if (error)   return <div className="mx-auto" style={{maxWidth:900,margin:'40px auto',padding:16,border:'1px solid #e5e7eb',borderRadius:12,background:'#fff'}}>{error}</div>;
      if (!pages.length) return <div className="mx-auto" style={{maxWidth:900,margin:'40px auto',padding:16,border:'1px solid #e5e7eb',borderRadius:12,background:'#fff'}}>No designs available.</div>;

      return (
        <EditCtx.Provider value={{ edit, setEdit, queue, setField }}>
          <>
            <div className="catw mx-auto">
              {pages.map((el, i) => {
                const designId = el.props['data-design-id'];
                return (
                  <div key={i} className="relative group">
                    {React.cloneElement(el, { id: `page-${i+1}` })}
                    <div className="print:hidden absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition flex gap-2">
                      <button
                        className="px-3 py-1.5 rounded-lg text-sm font-semibold bg-white/90 border border-red-200 text-red-600 hover:bg-red-50"
                        onClick={() => removeDesignById(designId)}
                        title="Remove this page (and delete design from Admin)"
                      >Remove</button>
                      <button
                        className="px-3 py-1.5 rounded-lg text-sm font-semibold bg-white/90 border border-slate-200 text-slate-800 hover:bg-slate-50"
                        onClick={() => openAdminForTheme(themeKey)}
                        title="Add a new page in this theme"
                      >Add Page</button>
                    </div>
                  </div>
                );
              })}
            </div>

            {mode !== 'selected' ? (
              <FloatingActions
                designs={allForTheme}
                selectedIds={selectedIds}
                syncSelection={syncSelection}
                onOpen={openSelectedFromApp}
                onPrint={printSelectedFromApp}
                onClear={clearSelectionAndRefresh}
                onSelectAllVisible={selectAllVisible}
                onInvertVisible={invertVisible}
                onDownloadEcard={downloadEcardPdf}
                edit={edit}
                setEdit={setEdit}
                onSaveAll={onSaveAll}
                pendingCount={Object.keys(queue).length}
              />
            ) : (
              <div className="fab print:hidden">
                <div className="fab-panel">
                  <button className="fab-btn" onClick={downloadEcardPdf} title="Download selected pages as an e-card PDF" disabled={!selectedIds.length}>
                    Download e-card
                  </button>
                </div>
              </div>
            )}
          </>
        </EditCtx.Provider>
      );
    }

    ReactDOM.createRoot(document.getElementById('app')).render(<App/>);
  </script>
</body>
</html>
